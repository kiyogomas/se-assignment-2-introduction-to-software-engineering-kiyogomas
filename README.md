[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/-ucQIGTc)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-718a45dd9cf7e7f842a935f5ebbe5719a5e09af4491e668f4dbf3b35d5cca122.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15236048&assignment_repo_type=AssignmentRepo)
# SE-Assignment-2
Assignment: Introduction to Software Engineering
Instructions:
Answer the following questions based on your understanding of software engineering concepts. Provide detailed explanations and examples where appropriate.

Questions:
What is software engineering, and how does it differ from traditional programming?
Software Development Life Cycle (SDLC):
Define Software Engineering:Is a branch of engineering that deals with designing, development and testing.

Software engineering process is mainly related with computers, computer programming, writing codes, building desktop or web application etc in a different kind of high level language. To develop a certain product we need a some proved methodology that is suitable for creating desired product .

Traditional programming traditional engineering, is the process of marketing, engineering design, manufacturing, testing and production where each stage of the development.

Explain the various phases of the Software Development Life Cycle. Provide a brief description of each phase.
a) Project Planning This is the phase of software development where by it is the first phase and it's all about  “What do we want?” Project planning is a vital role in the software delivery lifecycle since this is the part where the team estimates the cost and defines the requirements of the new software. 
b) Gathering Requirements & Analysis is where by the maximum information from client requirement for the product. 
c) Design in this phase the the program developer scrutinizes whether the prepared software suffices all the requirements of the end-user. Additionally, if the project is feasible for the customer technologically, practically, and financially. 
d) Coding or Implementation It means translating the design to a computer-legible language.the tasks are divided into modules or units and assigned to various developers. The developers will then start building the entire system by writing code using the programming languages they choose. 
e) Testing this is when the developers build the software, then it is deployed in the testing environment. Then the testing team tests the functionality of the entire system.the testing is done to ensure that the entire application works according to the customer requirements. 
f)  Deployment after the testing is done, and the product is ready for deployment, it is released for customers to use. The size of the project determines the complexity of the deployment. The users are then provided with the training or documentation that will help them to operate the software.  
g) Maintenance it is  the last phase of  where the developed product is taken care of. According to the changing user end environment or technology, the software is updated timely.

Agile vs. Waterfall Models:
Agile Models is suitable for projects requiring flexibility and constant requirements changes, such as software development, where customer feedback and engagement are critical while
Waterfall models is ideal for projects with well-defined stages and straightforward, linear requirements.

Compare and contrast the Agile and Waterfall models of software development. What are the key differences, and in what scenarios might each be preferred?
a) Agile model follows the incremental approach, where each incremental part is developed through iteration after every timebox while Waterfall model follows a sequential design process. 
b) Agile model is flexible as there is a possibility of changing the requirements even after starting the development process. while On the other hand, the waterfall model is rigid as it does not allow to modify the requirements once the development process starts. 
c)In the agile model, the measurement of progress is in terms of developed and delivered functionalities. while In the waterfall model, generally the measurement of success is in terms of completed and reviewed artifacts.
e)In Agile model, there is a high customer interaction. It is because, after every iteration, an incremental version is deployed to the customer. while Customer interaction in waterfall model is very less. It is because, in a waterfall model, the product is delivered to the customer after overall development.
f)Agile model is not a suitable model for small projects. The expenses of developing the small projects using agile is more than compared to other models. while Waterfall model works well in smaller size projects where requirements are easily understandable. But waterfall model is not suitable for developing the large projects.
Agile can be preferred from the following senerios Technical Technical,  Creative projects,Product innovation and development,Startups,Rapid 

Requirements Engineering:
is the process of identifying, eliciting, analyzing, specifying, validating, and managing the needs and expectations of stakeholders for a software system. 
What is requirements engineering? Describe the process and its importance in the software development lifecycle.
The process of requirement engineering in software development is as follows: 
a)  Feasibility Study-The feasibility study mainly concentrates on below five mentioned areas below. Among these Economic Feasibility Study is the most important part of the feasibility analysis and the Legal Feasibility Study is less considered feasibility analysis. 
b) Requirements Elicitation-It is related to the various ways used to gain knowledge about the project domain and requirements. The various sources of domain knowledge include customers, business manuals, the existing software of the same type, standards, and other stakeholders of the project. The techniques used for requirements elicitation include interviews, brainstorming, task analysis, Delphi technique, prototyping.
c)  Requirements Specification-This activity is used to produce formal software requirement models. All the requirements including the functional as well as the non-functional requirements and the constraints are specified by these models in totality. During specification, more knowledge about the problem may be required which can again trigger the elicitation process.
d) Requirements Verification and Validation
Verification: It refers to the set of tasks that ensures that the software correctly implements a specific function. Validation: It refers to a different set of tasks that ensures that the software that has been built is traceable to customer requirements. If requirements are not validated, errors in the requirement definitions would propagate to the successive stages resulting in a lot of modification and rework. The main steps for this process include:The requirements should be consistent with all the other requirements i.e. no two requirements should conflict with each other.
The requirements should be complete in every sense.
e)  Requirements Management is the process of analyzing, documenting, tracking, prioritizing, and agreeing on the requirement and controlling the communication with relevant stakeholders. This stage takes care of the changing nature of requirements. It should be ensured that the SRS is as modifiable as possible to incorporate changes in requirements specified by the end users at later stages too. Modifying the software as per requirements in a systematic and controlled manner is an extremely important part of the requirements engineering process
Software Design Principles:are concerned with providing means to handle the complexity of the design process effectively

Explain the concept of modularity in software design. How does it improve maintainability and scalability of software systems? 
Modularity in software design refers to dividing a system into separate modules or components.
Modular design can be applied to a wide range of systems, including mechanical systems, software systems, and buildings. It is often used to simplify the development and maintenance process, reduce costs, and improve the reliability and flexibility of the system.

Testing in Software Engineering: Is a method to assess the functionality of the software program. The process checks whether the actual software matches the expected requirements and ensures the software is bug-free.

Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing). Why is testing crucial in software development?
a) Unit testing- It a level of the software testing process where individual units/components of a software/system are tested. The purpose is to validate that each unit of the software performs as designed.
b) Intergration testing-It is a level of the software testing process where individual units are combined and tested as a group. The purpose of this level of testing is to expose faults in the interaction between integrated units.
c) System setting -It is a level of the software testing process where a complete, integrated system/software is tested. The purpose of this test is to evaluate the system’s compliance with the specified requirements. 
d) Acceptance testing -  It is a level of the software testing process where a system is tested for acceptability. The purpose of this test is to evaluate the system’s compliance with the business requirements and assess whether it is acceptable for delivery.

Testing is crucial in software development for the following reasons; 
a)Helps in saving money -The testing of software has a wide array of benefits. The cost-effectiveness of the project happens to be one of the top reasons why companies go for software testing Services.
b) Security - It is another crucial point why software testing should not be taken into consideration.
It is considered to be the most vulnerable and sensitive part. There are a bunch of situations in which the information and details of the users are stolen and they are used for the benefits.
c) Quality of the product -For ensuring that the specific product comes to life, it should work in accordance with the following.Following the needs of the product is a prerequisite as it is helpful in getting the prerequisite results.
d) Satisfaction of the customer - The primary objective of the owner of the products is offering the best satisfaction of the customers.The reasons why it is necessary to opt for software testing is due to the fact that it offers the prerequisite and perfect user experience.
e)Enhancing the development process - With the aid of Quality Assurance, you can find a wide array of scenarios and errors, for the reproduction of the error.It is really simple and the developers need to fix the same in no time. In addition to this, software testers should be working with the development team parallelly, which is useful in the acceleration of the development procedure.

VERSION CONTROL SYSTEM: Version control, also known as source control, is the practice of tracking and managing changes to software code. Version control systems are software tools that help software teams manage changes to source code over time.

What are version control systems, and why are they important in software development? Give examples of popular version control systems and their features. Version control system are very importatnt in software development due to the following:
a) Quality - Version control encourages a culture of continuous peer review and collaboration, leading to significant improvements in code quality. By facilitating detailed tracking of every change, teams can easily review, comment, and refine their work, ensuring adherence to best practices and standards. This collaborative scrutiny not only elevates the quality of the output but also aids in early bug detection and resolution.
b) Acceleration - Version control systems streamline development processes, enabling faster iteration and delivery of features. Efficient branching and merging capabilities allow developers to work concurrently on various aspects of a project without interference, significantly reducing the time from development to deployment. Additionally, the ability to quickly revert to previous versions minimizes downtime when addressing issues, keeping the project momentum steady.
c) Visibility - A central repository in a version control system acts as the single source of truth, enhancing project transparency and accountability. This centralized view of the project's evolution aids in better planning, tracking, and collaboration, as every team member has access to the latest updates and historical changes. The integration with project management tools further bolsters project oversight, linking code changes directly to tasks and milestones. 

Software Project Management is a proper way of planning and leading software projects. It is a part of project management in which software projects are planned, implemented, monitored, and controlled.

Discuss the role of a software project manager. 
A project manager has to face many difficult situations to accomplish these works. The job responsibilities of a project manager range from invisible activities like building up team morale to highly visible customer presentations. The following are the roles of project manager;
Project managers play a vital role in efficient project execution, meeting client expectations, budget adherence, and delivering quality software. Below is a list of a project manager’s key responsibilities in a software development environment:

a) Planning & Scope: In the early stages of a software project, the project manager is the architect defining its essence, objectives, proper scope, and deliverables. They create a detailed project plan with milestones, allocate resources efficiently, and maintain budgetary discipline, ensuring the project’s success and approval with all stakeholders.
b) Requirements & Analysis: Project managers facilitate vital stakeholder collaboration, comprehensively refining project requirements and definition. They work with the project team to assess the overall feasibility, identify potential pitfalls, and minimize risks. They also detail precise and actionable requirements for meeting the desired outcomes.
c) Resource Management: A primary function of a project manager is to orchestrate the use of resources with precision. They assemble and guide project teams, carefully choosing members with skills matching the project’s needs. Beyond initial assembly, they optimize resource allocation, recognizing that it’s about strategic distribution for judicious investment of assets and time. This multifaceted role ensures harmonious functioning, resulting in precision and excellence throughout the project’s performance.
d) Risk Management: A project manager’s proactive approach is essential in navigating potential risks. Beyond risk identification, they foster a continuous risk-awareness culture within the team. Their foresight ensures swift responses to challenges, safeguarding the project’s path to successful completion.
e) Monitoring & Control: Project managers oversee project progress and key performance indicators, ensuring each phase runs smoothly. More than just observers, they proactively guide projects to success, quickly addressing deviations and realigning the project’s direction when this occurs. Acting as the project’s compass, they ensure it navigates challenges and remains on the path to success.
f) Quality Assurance: Effective project managers are champions of software quality. They set rigorous standards that serve as blueprints for excellence, ensuring each team member understands and adheres to these benchmarks. Regular quality checks, inspections, and tests are conducted to maintain these standards.
g) Stakeholder Communication: Project managers assume the role of the central point of contact, connecting technical teams with stakeholders and resources and acting as the conduits through which information flows. They ensure that all stakeholders, whether technical experts or project sponsors, are not only privy to project progress, but also attuned to changes and milestones. It’s their responsibility to nurture a collaborative environment among team members and make sure that everybody is working towards the same goal.
h) Documentation & Reporting: Project managers are the stewards of project documentation, maintaining records such as project plans, status reports, and meeting minutes. These documents serve as the project’s archive, detailing its progress and capturing any changes or key decisions. Beyond record-keeping, project managers create reports for stakeholders to keep them informed about the project’s status and foster transparency.
i) Change Management: Project managers orchestrate change requests and evaluate their impact on the project’s goals, timelines, and budgets. Their role involves not only assessing changes, but also advocating for necessary adjustments and securing approvals. This ensures that changes are strategically aligned with the project’s direction and that the project adapts effectively, keeping it on track to successful completion.
j) Closure & Evaluation: Project managers play a crucial role in project success by overseeing technical completion and facilitating a smooth transition from development to deployment or maintenance. They conduct post-project evaluations to extract insights, enabling teams to improve. Archiving project documents ensures compliance and knowledge retention, making project managers essential for efficient project execution and organizational growth.
k) Client Satisfaction: Project managers actively engage with clients to gather feedback and address any concerns that may arise. They will additionally provide post-project support to ensure the client’s continued satisfaction throughout the project life cycle.
Continuous Improvement: Staying abreast of industry best practices, emerging technologies and project management tools, and evolving project management methodologies is a hallmark of a skilled project manager. They will consistently design and implement process enhancements to help elevate the efficiency and effectiveness of project management practices

Software Maintenance:Software maintenance is the process of changing, modifying, and updating software to keep up with customer needs. Software maintenance is done after the product has launched for several reasons including improving the software overall, correcting issues or bugs, to boost performance, and more.

Define software maintenance and explain the different types of maintenance activities. Why is maintenance an essential part of the software lifecycle? There are four different software maintenance types, which are defined for various reasons and purposes
a) Adaptive Maintenance
Adaptive software maintenance is the process of conversion in the system to keep the software compatible with changing business needs and technical evolution. This software maintenance type primarily focuses on software frameworks. It is made in response to new operating systems, platforms, and hardware to retain continuity with the software.
b) Perfective Maintenance
Perfective Maintenance is a process of modifying all elements, functionalities, and abilities to enhance system operations and performance. The software’s receptiveness and usability are solved by perfective software maintenance. It includes altering current software functionality by improving, removing, or inserting new features or functions.
c) Corrective Maintenance
Identifying errors in the existing solution and correcting them to make it works more accurately. This software maintenance activity aims to eliminate and fix bugs or issues in the software. Corrective software maintenance is usually done in the form of small updates frequently.
d) Preventive Maintenance
Preventive software maintenance service helps in preventing the system from any forthcoming vulnerabilities. Preventive maintenance defines improvements of the software, which is done to safeguard the software for the future. It is carried out to prevent the product from any potential software alteration. Preventive maintenance also makes it easier to scale or maintain your code and handle your legacy system.
Software maintainance is essential part due to the following:
a)To improve performance - Your software would need fine-tuning so that it performs optimally. 
Many a time, after the software goes live and the end users use it, problems arise. With a maintenance program, you can easily access upgrades all year round to address and fix issues faced by users. These upgrades improve the overall performance and functionality of the application.
b) To fix bugs and remove glitches - The goal is to make the software as bug-free as possible in the first place and have a plan to quickly fix those as and when they may arise. However, there are times when the magnitude of the bug makes an immediate fix impossible. That’s why it is important to establish a standardized process to address the bugs and glitches that arise in the software. 
c) To add enhancements and insertions -Enhancements and insertions to the software (user interface to coding elements) need to be made using the latest tools and technologies. This change makes the system adaptive to cope with changing circumstances.
A well-defined software maintenance plan will help you with just that. It will keep your software in pace with the recent technology and help you leverage all the benefits of the new technology.
d) To allow for modification and reconfiguration -Modification and reconfiguration help improve the underlying architecture of the system. Design maintenance can include adding new features, changing existing ones, or updating security protocols.
e) To future-proof your business - Software maintenance ensures that performance issues are addressed as soon as possible, preventing them from escalating into more significant issues.
When software maintenance tasks are completed regularly, you can rest assured that in case something goes down, there’s a contingency plan in place. This can be done through proper documentation on how the maintenance team will respond to certain critical issues. Backup and disaster recovery plans should be written down and implemented.

Ethical Considerations in Software Engineering: 
 are a set of principles that guide your research designs and practices. These principles include voluntary participation, informed consent, anonymity, confidentiality, potential for harm, and results communication.

What are some ethical issues that software engineers might face? How can software engineers ensure they adhere to ethical standards in their work?
The followinga are wthical issues that software engineer might face,
a) Addictive design - Every developer yearns to create applications that people love to use -- that's just good UX design. The problem is that some teams craft apps that people love too much. There is an ethical concern about the role of digital platforms, such as social media.As long as social media companies profit from outrage, confusion, addiction and depression, our well-being and democracy are at risk," argue critics like Tristan Harris of the Center for Humane Technology. Harris notably went viral while at working Google, with a presentation about the push for addictive technology design and companies' moral responsibility in society.
b) Questionable personal data ownership - AI-based processing of biometric and other contextual data about customers has increased exponentially with device and software evolution. Software can profile users and predict behaviors at a scary level of detail.
"Usually, the ethical question is [one of] what to do with that data," said Miguel Lopes, vice president of product line management at Vidyo, a video conference platform. This ethical issue is a dilemma for developers in every kind of business -- not just the social media giants who make the news.
c) Algorithmic bias - Technology can amplify existing biases. "One of the more pressing ethical issues facing today's developers is bias," said Spencer Lentz, principal, AI and digital process automation, digital customer experience, at consulting firm Capgemini.Bias often enters the system undetected -- Lentz compares bias to a virus. Computers themselves have no inherent moral framework. Software can only learn from the training it is given. Therefore, developers and data scientists must scrub bias from the training data and the algorithms they build. From a developer's perspective, bias often centers on eliminating options for the wrong reasons
An algorithm directs information collection and building a profile, but the subsequent actions are intentional, and the developer is ordinarily aware of the power of this data in contex
d) Application security is growing in importance as software plays a larger role in our online and offline environments.Developers often only address security after code release, rather than during development. As a result, the software community lacks secure development standards. "The emphasis is almost entirely on getting a product out to market," said Randolph Morris, CEO of Bit Developers, a software development consultancy. Once a software product is publicly available, the focus shifts to new features and performance optimization, so security continues to have minimal prominence.

Submission Guidelines:
Your answers should be well-structured, concise, and to the point.
Provide real-world examples or case studies wherever possible.
Cite any references or sources you use in your answers.
Submit your completed assignment by [due date].
